from unittest.mock import Mock, patch, call
from queue import Queue
from quactrl.services.common import (
    OneItemFlowService, PullRunner, MethodRepo, ProcessAdapter
    )
from tests import TestWithPatches, current


@current
class A_OneItemFlowService(TestWithPatches):
    def setup_method(self, method):
        self.create_patches([
            'quactrl.services.common.ProcessAdapter',
            'quactrl.services.common.PullRunner',
            'quactrl.services.common.InsertItemError'
            ])
        self.env = Mock()
        self.oifs = OneItemFlowService(self.env)

    def should_init_with_environment(self):
        oifs = self.oifs

        assert oifs.operation == self.PullRunner.return_value
        assert oifs.generator == self.PullRunner.return_value

        assert self.ProcessAdapter.call_count == 2
        # assert
        # assert self.oifs.dal == self.env.dal
        # assert self.oifs.view == self.env.view
        # assert self.oifs.resource is None
        # assert self.oifs.main_operation is None
        # assert self.oifs.generator is None

    def should_enter_item(self):
        item_data = {'tracking': '123456',
                     'resource_key': 'partnumber'}
        responsible = 'john'

        oifs = self.oifs
        op_adapter = oifs.operation.adapter
        generator = oifs.generator
        tokens = oifs.operation.adapter.get_tokens.return_value

        # The token is on stock at source
        oifs.enter_item(item_data, responsible)
        assert (call((tokens, responsible)) in
                oifs.operation.source.put.mock_calls)

        #The token shall be generated by generator
        op_adapter.get_tokens.return_value = None
        generator.is_loaded.return_value = True
        oifs.enter_item(item_data, responsible)

        print(generator.source.put.mock_calls)
        assert (call(((item_data, 1.0), responsible))
                in generator.origin.put.mock_calls)
        #There is a Exception when no generator and token in location
        #TODO

    def should_start(self):
        oifs = self.oifs
        oifs.operation = Mock()
        oifs.generator = Mock()

        oifs.generator.is_loaded.return_value = False
        self.oifs.start()

        assert oifs.operation.start.called
        assert not oifs.generator.start.called

        oifs.generator.is_loaded.return_value = True
        oifs.start()

        assert oifs.generator.start.called

    def should_stop(self):
        self.oifs.generator.path_is_loaded = Mock(return_value=False)

        self.oifs.stop()

        self.oifs.operation.origin.put.assert_called_with(None)
        assert call(None) not in self.oifs.generator.origin.put.calls


class Stuff:
    pass

@current
def test_method_repo():
    assert MethodRepo.get('test') is None
    assert MethodRepo.get('tests.services.test_common.Stuff') == Stuff


@current
class A_PullRunner(TestWithPatches):
    def setup_method(self, method):
        self.create_patches([
            'quactrl.services.common.MethodRepo',
            'quactrl.services.common.StepRunner'
        ])
        self.interrupt_event = Mock()
        self.controller = Mock()
        self.runner = PullRunner(interrupt_event=self.interrupt_event, controller=self.controller)

    def should_init_properly(self):
        runner = self.runner
        assert runner.interrupt_event == self.interrupt_event
        assert runner.controller == self.controller
        assert type(runner.origin) is Queue
        assert type(runner.destination) is Queue

        runner = PullRunner()

        assert runner.interrupt_event is None
        assert runner.controller is None

    def prepare_thread(self):
        runner = self.runner
        runner.interrupt_event.is_set.return_value = False
        runner. load_process = Mock()
        runner.path = Mock()
        runner.steps = [Mock()]

    def should_run_till_stop(self):
        self.prepare_thread()
        runner = self.runner

        runner.start()
        runner.origin.put(((Mock(name='token')), 'jonh'))
        runner.origin.put(None)

        while runner.is_alive():
            pass

        assert runner.path.process_tokens.call_count == 1
        print(self.controller.notify.mock_calls)
        self.controller.notify.assert_called_with('process_finished', runner.path)

    def should_run_till_interrupt(self):
        self.prepare_thread()
        runner = self.runner
        runner.origin.get.return_value = ([], None)

        runner.start()
        self.interrupt_event.is_set.return_value = True
        while runner.is_alive():
            pass

    def should_load_process(self):
        runner = self.runner
        runner.path = Mock()
        runner.adapter = Mock()
        method = self.MethodRepo.get.return_value
        runner.path.children = [Mock(name='step{}'.format(i))
                                for i in range(2)]

        runner.load_process()

        assert self.MethodRepo.get.called
        assert self.StepRunner.call_count == 2
        assert runner.method == method

    def should_execute(self):
        resources = [Mock() for _ in range(2)]
        method = Mock()

        self.runner.method = method
        self.runner.execute(resources)

        assert method.called
